[{"content":"基于python的struct模块实现简单的ByteBuf 写在前面 在网络编程中需要将消息序列化为二进制序列打包传输。python标准库中的struct模块提供了pack、unpack等函数将基本数据类型转换为对应的bytes数组。使用pack、unpack需要在传参是需要关注字节序（大小端）、格式等，其中字节序有@、=、\u0026lt;、\u0026gt;、！五种，格式约21种，使用成本相对高。所以参考Netty的ByteBuf及Rust的bytes库中的Buf、BufMut为Python简单封装一个类似的ByteBuf。\nnetty中ByteBuf的基本结构如下：\n1 2 3 4 5 6 +-------------------+------------------+------------------+ | discardable bytes | readable bytes | writable bytes | | | (CONTENT) | | +-------------------+------------------+------------------+ | | | | 0 \u0026lt;= readerIndex \u0026lt;= writerIndex \u0026lt;= capacity 一、Buf接口设计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 import abc import struct from numpy import longlong \u0026#34;\u0026#34;\u0026#34; https://netty.io/4.0/api/io/netty/buffer/ByteBuf.html https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html https://docs.rs/bytes/1.1.0/bytes/ \u0026#34;\u0026#34;\u0026#34; class Buf(metaclass=abc.ABCMeta): class ByteOrder: NATIVE = \u0026#39;@\u0026#39; STD_NATIVE = \u0026#39;=\u0026#39; LITTLE_ENDIAN = \u0026#39;\u0026lt;\u0026#39; BIG_ENDIAN = \u0026#39;\u0026gt;\u0026#39; NETWORK = \u0026#39;!\u0026#39; PAD_BYTE = \u0026#39;x\u0026#39; CHAR = \u0026#39;c\u0026#39; SIGNED_CHAR = \u0026#39;b\u0026#39; UNSIGNED_CHAR = \u0026#39;B\u0026#39; BOOLEAN = \u0026#39;?\u0026#39; SHORT = \u0026#39;h\u0026#39; UNSIGNED_SHORT = \u0026#39;H\u0026#39; INT = \u0026#39;i\u0026#39; UNSIGNED_INT = \u0026#39;I\u0026#39; LONG = \u0026#39;l\u0026#39; UNSIGNED_LONG = \u0026#39;L\u0026#39; LONG_LONG = \u0026#39;q\u0026#39; UNSIGNED_LONG_LONG = \u0026#39;Q\u0026#39; SSIZE_T = \u0026#39;n\u0026#39; SIZE_T = \u0026#39;N\u0026#39; EXPONENT = \u0026#39;e\u0026#39; FLOAT = \u0026#39;f\u0026#39; DOUBLE = \u0026#39;d\u0026#39; CHAR_ARR = \u0026#39;s\u0026#39; CHAR_ARR1 = \u0026#39;p\u0026#39; VOID = \u0026#39;P\u0026#39; @abc.abstractmethod def readable_bytes_len(self) -\u0026gt; int: pass @abc.abstractmethod def to_bytes(self) -\u0026gt; bytearray: pass @abc.abstractmethod def write_i8(self, value: int): pass @abc.abstractmethod def write_u8(self, value: int): pass @abc.abstractmethod def write_bool(self, value: bool): pass @abc.abstractmethod def write_i16(self, value: int): pass @abc.abstractmethod def write_i16_le(self, value: int): pass @abc.abstractmethod def write_u16(self, value: int): pass @abc.abstractmethod def write_u16_le(self, value: int): pass @abc.abstractmethod def write_i32(self, value: int): pass @abc.abstractmethod def write_i32_le(self, value: int): pass @abc.abstractmethod def write_u32(self, value: int): pass @abc.abstractmethod def write_u32_le(self, value: int): pass @abc.abstractmethod def write_i64(self, value: longlong): pass @abc.abstractmethod def write_i64_le(self, value: longlong): pass @abc.abstractmethod def write_u64(self, value: longlong): pass @abc.abstractmethod def write_u64_le(self, value: longlong): pass @abc.abstractmethod def write_f32(self, value: float): pass @abc.abstractmethod def write_f32_le(self, value: float): pass @abc.abstractmethod def write_f64(self, value: float): pass @abc.abstractmethod def write_f64_le(self, value: float): pass @abc.abstractmethod def write_bytes(self, value: bytes): pass @abc.abstractmethod def read_i8(self): pass @abc.abstractmethod def read_u8(self): pass @abc.abstractmethod def read_bool(self): pass @abc.abstractmethod def read_i16(self): pass @abc.abstractmethod def read_i16_le(self): pass @abc.abstractmethod def read_u16(self): pass @abc.abstractmethod def read_u16_le(self): pass @abc.abstractmethod def read_i32(self): pass @abc.abstractmethod def read_i32_le(self): pass @abc.abstractmethod def read_u32(self): pass @abc.abstractmethod def read_u32_le(self): pass @abc.abstractmethod def read_i64(self): pass @abc.abstractmethod def read_i64_le(self): pass @abc.abstractmethod def read_u64(self): pass @abc.abstractmethod def read_u64_le(self): pass @abc.abstractmethod def read_f32(self): pass @abc.abstractmethod def read_f32_le(self): pass @abc.abstractmethod def read_f64(self): pass @abc.abstractmethod def read_f64_le(self): pass @abc.abstractmethod def read_bytes(self, length: int) -\u0026gt; bytes: pass 二、ByteBuf具体实现 ByteBuf底层使用可以字节数组bytearray作存储，记录分别读写的位置。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 import abc import struct from numpy import longlong class ByteBuf(Buf): def __init__(self, buf: bytearray = None) -\u0026gt; None: if buf is None: self.buf = bytearray() self.write_index = 0 else: self.buf = buf self.write_index = len(buf) self.read_index = 0 def check_readable_bytes_len(self, length: int): if self.readable_bytes_len() \u0026lt; length: raise Exception(\u0026#34;readable bytes length must greater than or equal %d\u0026#34; % length) def readable_bytes_len(self) -\u0026gt; int: return self.write_index - self.read_index def to_bytes(self) -\u0026gt; bytearray: return self.buf def write_i8(self, value: int): self.buf += struct.pack(Buf.SIGNED_CHAR, value) self.write_index += 1 def write_u8(self, value: int): self.buf += struct.pack(Buf.UNSIGNED_CHAR, value) self.write_index += 1 def write_bool(self, value: bool): self.buf += struct.pack(Buf.BOOLEAN, value) self.write_index += 1 def write_i16(self, value: int): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.SHORT, value) self.write_index += 2 def write_i16_le(self, value: int): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.SHORT, value) self.write_index += 2 def write_u16(self, value: int): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.UNSIGNED_SHORT, value) self.write_index += 2 def write_u16_le(self, value: int): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.UNSIGNED_SHORT, value) self.write_index += 2 def write_i32(self, value: int): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.INT, value) self.write_index += 4 def write_i32_le(self, value: int): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.INT, value) self.write_index += 4 def write_u32(self, value: int): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.UNSIGNED_INT, value) self.write_index += 4 def write_u32_le(self, value: int): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.UNSIGNED_INT, value) self.write_index += 4 def write_i64(self, value: longlong): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.LONG_LONG, value) self.write_index += 8 def write_i64_le(self, value: longlong): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.LONG_LONG, value) self.write_index += 8 def write_u64(self, value: longlong): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.UNSIGNED_LONG_LONG, value) self.write_index += 8 def write_u64_le(self, value: longlong): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.UNSIGNED_LONG_LONG, value) self.write_index += 8 def write_f32(self, value: float): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.FLOAT, value) self.write_index += 4 def write_f32_le(self, value: float): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.FLOAT, value) self.write_index += 4 def write_f64(self, value: float): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.DOUBLE, value) self.write_index += 8 def write_f64_le(self, value: float): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.DOUBLE, value) self.write_index += 8 def write_bytes(self, value: bytes): if len(value) \u0026gt; 0: self.buf += value self.write_index += len(value) def read_i8(self) -\u0026gt; int: self.check_readable_bytes_len(1) ret = struct.unpack(Buf.SIGNED_CHAR, self.buf[self.read_index:self.read_index + 1]) self.read_index += 1 return ret[0] def read_u8(self): self.check_readable_bytes_len(1) ret = struct.unpack(Buf.UNSIGNED_CHAR, self.buf[self.read_index:self.read_index + 1]) self.read_index += 1 return ret[0] def read_bool(self): self.check_readable_bytes_len(1) ret = struct.unpack(Buf.BOOLEAN, self.buf[self.read_index:self.read_index + 1]) self.read_index += 1 return ret[0] def read_i16(self): self.check_readable_bytes_len(2) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.SHORT, self.buf[self.read_index:self.read_index + 2]) self.read_index += 2 return ret[0] def read_i16_le(self): self.check_readable_bytes_len(2) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.SHORT, self.buf[self.read_index:self.read_index + 2]) self.read_index += 2 return ret[0] def read_u16(self): self.check_readable_bytes_len(2) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.UNSIGNED_SHORT, self.buf[self.read_index:self.read_index + 2]) self.read_index += 2 return ret[0] def read_u16_le(self): self.check_readable_bytes_len(2) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.UNSIGNED_SHORT, self.buf[self.read_index:self.read_index + 2]) self.read_index += 2 return ret[0] def read_i32(self): ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.INT, self.buf[self.read_index:self.read_index + 4]) self.read_index += 4 return ret[0] def read_i32_le(self): self.check_readable_bytes_len(4) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.INT, self.buf[self.read_index:self.read_index + 4]) self.read_index += 4 return ret[0] def read_u32(self): self.check_readable_bytes_len(4) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.UNSIGNED_INT, self.buf[self.read_index:self.read_index + 4]) self.read_index += 4 return ret[0] def read_u32_le(self): self.check_readable_bytes_len(4) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.UNSIGNED_INT, self.buf[self.read_index:self.read_index + 4]) self.read_index += 4 return ret[0] def read_i64(self): self.check_readable_bytes_len(8) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.LONG_LONG, self.buf[self.read_index:self.read_index + 8]) self.read_index += 8 return ret[0] def read_i64_le(self): self.check_readable_bytes_len(8) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.LONG_LONG, self.buf[self.read_index:self.read_index + 8]) self.read_index += 8 return ret[0] def read_u64(self): self.check_readable_bytes_len(8) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.UNSIGNED_LONG_LONG, self.buf[self.read_index:self.read_index + 8]) self.read_index += 8 return ret[0] def read_u64_le(self): self.check_readable_bytes_len(8) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.UNSIGNED_LONG_LONG, self.buf[self.read_index:self.read_index + 8]) self.read_index += 8 return ret[0] def read_f32(self): self.check_readable_bytes_len(4) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.FLOAT, self.buf[self.read_index:self.read_index + 4]) self.read_index += 4 return ret[0] def read_f32_le(self): self.check_readable_bytes_len(4) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.FLOAT, self.buf[self.read_index:self.read_index + 4]) self.read_index += 4 return ret[0] def read_f64(self): self.check_readable_bytes_len(8) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.DOUBLE, self.buf[self.read_index:self.read_index + 8]) self.read_index += 8 return ret[0] def read_f64_le(self): self.check_readable_bytes_len(8) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.DOUBLE, self.buf[self.read_index:self.read_index + 8]) self.read_index += 8 return ret[0] def read_bytes(self, length: int) -\u0026gt; bytearray: self.check_readable_bytes_len(length) ret = self.buf[self.read_index:self.read_index + length] self.read_index += length return ret 三、编写单元测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 import os, sys sys.path.append(os.getcwd()) from unittest import TestCase import pytest from buf.byte_buf import ByteBuf class TestByteBuf(TestCase): def setUp(self) -\u0026gt; None: self.buf = ByteBuf() def test_byte_buf(self) -\u0026gt; int: self.buf.write_i8(127) self.buf.write_i8(127) self.buf.write_i8(1) self.buf.write_f32(1) buf1 = ByteBuf(self.buf.to_bytes()) self.assertEqual(7, buf1.readable_bytes_len()) def test_readable_bytes_len(self) -\u0026gt; int: self.buf.write_i8(127) self.buf.write_i8(127) self.buf.write_i8(1) self.buf.write_f32(1) self.assertEqual(7, self.buf.readable_bytes_len()) def test_to_bytes(self) -\u0026gt; bytes: self.buf.write_i8(127) self.buf.write_i8(127) self.buf.write_i8(1) self.assertEqual(b\u0026#39;\\x7f\\x7f\\x01\u0026#39;, self.buf.to_bytes()) def test_write_i8(self): self.buf.write_i8(-128) self.buf.write_i8(0) self.buf.write_i8(127) self.assertEqual(-128, self.buf.read_i8()) self.assertEqual(0, self.buf.read_i8()) self.assertEqual(127, self.buf.read_i8()) def test_write_i8_failed1(self): with pytest.raises(Exception): self.buf.write_i8(128) def test_write_i8_failed2(self): with pytest.raises(Exception): self.buf.write_i8(-129) def test_write_i8_failed3(self): with pytest.raises(Exception): self.buf.read_i8() def test_write_u8(self): self.buf.write_u8(0) self.buf.write_u8(127) self.buf.write_u8(255) self.assertEqual(0, self.buf.read_u8()) self.assertEqual(127, self.buf.read_u8()) self.assertEqual(255, self.buf.read_u8()) def test_write_u8_failed1(self): with pytest.raises(Exception): self.buf.write_u8(-1) def test_write_u8_failed2(self): with pytest.raises(Exception): self.buf.write_u8(256) def test_write_bool(self): self.buf.write_bool(True) self.buf.write_bool(False) self.buf.write_bool(1) self.buf.write_bool(0) self.buf.write_bool(22222) self.assertTrue(self.buf.read_bool()) self.assertFalse(self.buf.read_bool()) self.assertTrue(self.buf.read_bool()) self.assertFalse(self.buf.read_bool()) self.assertTrue(self.buf.read_bool()) def test_write_i16(self): self.buf.write_i16(-32768) self.buf.write_i16(0) self.buf.write_i16(127) self.buf.write_i16(32767) self.assertEqual(-32768, self.buf.read_i16()) self.assertEqual(0, self.buf.read_i16()) self.assertEqual(127, self.buf.read_i16()) self.assertEqual(32767, self.buf.read_i16()) def test_write_i16_failed1(self): with pytest.raises(Exception): self.buf.write_i16(-32769) def test_write_i16_failed2(self): with pytest.raises(Exception): self.buf.write_i16(32768) def test_write_i16_le(self): self.buf.write_i16_le(-32768) self.buf.write_i16_le(0) self.buf.write_i16_le(127) self.buf.write_i16_le(32767) self.buf.write_i16_le(32767) self.assertEqual(-32768, self.buf.read_i16_le()) self.assertEqual(0, self.buf.read_i16_le()) self.assertEqual(127, self.buf.read_i16_le()) self.assertEqual(32767, self.buf.read_i16_le()) self.assertNotEqual(32767, self.buf.read_i16()) def test_write_u16(self): self.buf.write_u16(0) self.buf.write_u16(127) self.buf.write_u16(65535) self.assertEqual(0, self.buf.read_u16()) self.assertEqual(127, self.buf.read_u16()) self.assertEqual(65535, self.buf.read_u16()) def test_write_u16_failed1(self): with pytest.raises(Exception): self.buf.write_u16(-1) def test_write_u16_failed2(self): with pytest.raises(Exception): self.buf.write_u16(65536) def test_write_u16_le(self): self.buf.write_u16_le(0) self.buf.write_u16_le(127) self.buf.write_u16_le(65535) self.buf.write_u16_le(65534) self.assertEqual(0, self.buf.read_u16_le()) self.assertEqual(127, self.buf.read_u16_le()) self.assertEqual(65535, self.buf.read_u16_le()) self.assertNotEqual(65534, self.buf.read_u16()) def test_write_i32(self): self.buf.write_i32(-2 ** 31) self.buf.write_i32(0) self.buf.write_i32(127) self.buf.write_i32(127) self.buf.write_i32(2 ** 31 - 1) self.assertEqual(-2 ** 31, self.buf.read_i32()) self.assertEqual(0, self.buf.read_i32()) self.assertEqual(127, self.buf.read_i32()) self.assertNotEqual(127, self.buf.read_i32_le()) self.assertEqual(2 ** 31 - 1, self.buf.read_i32()) def test_write_i32_le(self): self.buf.write_i32_le(-2 ** 31) self.buf.write_i32_le(0) self.buf.write_i32_le(127) self.buf.write_i32_le(127) self.buf.write_i32_le(2 ** 31 - 1) self.assertEqual(-2 ** 31, self.buf.read_i32_le()) self.assertEqual(0, self.buf.read_i32_le()) self.assertEqual(127, self.buf.read_i32_le()) self.assertNotEqual(127, self.buf.read_i32()) self.assertEqual(2 ** 31 - 1, self.buf.read_i32_le()) def test_write_u32(self): self.buf.write_u32(0) self.buf.write_u32(127) self.buf.write_u32(127) self.buf.write_u32(2 ** 32 - 1) self.assertEqual(0, self.buf.read_u32()) self.assertEqual(127, self.buf.read_u32()) self.assertNotEqual(127, self.buf.read_u32_le()) self.assertEqual(2 ** 32 - 1, self.buf.read_u32()) def test_write_u32_failed1(self): with pytest.raises(Exception): self.buf.write_u32(-1) def test_write_u32_failed2(self): with pytest.raises(Exception): self.buf.write_u32(2 ** 32) def test_write_u32_le(self): self.buf.write_u32_le(0) self.buf.write_u32_le(127) self.buf.write_u32_le(127) self.buf.write_u32_le(2 ** 32 - 1) self.assertEqual(0, self.buf.read_u32_le()) self.assertEqual(127, self.buf.read_u32_le()) self.assertNotEqual(127, self.buf.read_u32()) self.assertEqual(2 ** 32 - 1, self.buf.read_u32_le()) def test_write_i64(self): self.buf.write_i64(- 2 ** 63) self.buf.write_i64(0) self.buf.write_i64(127) self.buf.write_i64(127) self.buf.write_i64(2 ** 63 - 1) self.assertEqual(-2 ** 63, self.buf.read_i64()) self.assertEqual(0, self.buf.read_i64()) self.assertEqual(127, self.buf.read_i64()) self.assertNotEqual(127, self.buf.read_i64_le()) self.assertEqual(2 ** 63 - 1, self.buf.read_i64()) def test_write_i64_le(self): self.buf.write_i64_le(- 2 ** 63) self.buf.write_i64_le(0) self.buf.write_i64_le(127) self.buf.write_i64_le(127) self.buf.write_i64_le(2 ** 63 - 1) self.assertEqual(-2 ** 63, self.buf.read_i64_le()) self.assertEqual(0, self.buf.read_i64_le()) self.assertEqual(127, self.buf.read_i64_le()) self.assertNotEqual(127, self.buf.read_i64()) self.assertEqual(2 ** 63 - 1, self.buf.read_i64_le()) def test_write_u64(self): self.buf.write_i64_le(- 2 ** 63) self.buf.write_i64_le(0) self.buf.write_i64_le(127) self.buf.write_i64_le(127) self.buf.write_i64_le(2 ** 63 - 1) self.assertEqual(-2 ** 63, self.buf.read_i64_le()) self.assertEqual(0, self.buf.read_i64_le()) self.assertEqual(127, self.buf.read_i64_le()) self.assertNotEqual(127, self.buf.read_i64()) self.assertEqual(2 ** 63 - 1, self.buf.read_i64_le()) def test_write_u64_le(self): self.buf.write_u64_le(0) self.buf.write_u64_le(127) self.buf.write_u64_le(127) self.buf.write_u64_le(2 ** 64 - 1) self.assertEqual(0, self.buf.read_u64_le()) self.assertEqual(127, self.buf.read_u64_le()) self.assertNotEqual(127, self.buf.read_u64()) self.assertEqual(2 ** 64 - 1, self.buf.read_u64_le()) def test_write_f32(self): self.buf.write_f32(0) self.buf.write_f32(127) self.buf.write_f32(127) self.buf.write_f32(12.0) self.assertEqual(0, self.buf.read_f32()) self.assertEqual(127, self.buf.read_f32()) self.assertNotEqual(127, self.buf.read_f32_le()) self.assertEqual(12.0, self.buf.read_f32()) def test_write_f32_le(self): self.buf.write_f32_le(0) self.buf.write_f32_le(127) self.buf.write_f32_le(127) self.buf.write_f32_le(12.0) self.assertEqual(0, self.buf.read_f32_le()) self.assertEqual(127, self.buf.read_f32_le()) self.assertNotEqual(127, self.buf.read_f32()) self.assertEqual(12.0, self.buf.read_f32_le()) def test_write_f64(self): self.buf.write_f64(0) self.buf.write_f64(127) self.buf.write_f64(127) self.buf.write_f64(12.0) self.assertEqual(0, self.buf.read_f64()) self.assertEqual(127, self.buf.read_f64()) self.assertNotEqual(127, self.buf.read_f64_le()) self.assertEqual(12.0, self.buf.read_f64()) def test_write_f64_le(self): self.buf.write_f64_le(0) self.buf.write_f64_le(127) self.buf.write_f64_le(127) self.buf.write_f64_le(12.0) self.assertEqual(0, self.buf.read_f64_le()) self.assertEqual(127, self.buf.read_f64_le()) self.assertNotEqual(127, self.buf.read_f64()) self.assertEqual(12.0, self.buf.read_f64_le()) def test_write_bytes(self): self.buf.write_bytes(b\u0026#39;hello\u0026#39;) self.assertEqual(b\u0026#39;hel\u0026#39;, self.buf.read_bytes(3)) self.assertEqual(b\u0026#39;lo\u0026#39;, self.buf.read_bytes(2)) 执行单元测试\n1 2 3 buf\\test_byte_buf.py .................................. [100%] ============================================================================================= 34 passed in 0.60s ============================================================================================== 四、总结： 该ByteBuf不考虑线程安全，仅提供了顺序读写的能力，未来在实际使用过程中根据实际完善，比如随机读写能力，基于多个ByteBuf进行Wrapper组合构建新的ByteBuf等。\n参考文档：\nhttps://netty.io/4.0/api/io/netty/buffer/ByteBuf.html https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html https://docs.rs/bytes/1.1.0/bytes/\n下期预告：基于Bytebuf实现对交易所交易接口消息的封装 ","date":"2025-05-11T18:29:30+08:00","permalink":"https://xinchentechnote.github.io/note/p/%E5%9F%BA%E4%BA%8Epython%E7%9A%84struct%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84bytebuf/","title":"基于python的struct模块实现简单的ByteBuf"},{"content":"Java 字符串拼接性能实测：基于 JMH 的微基准测试 在 Java 开发中，字符串拼接操作无处不在。你可能会直接使用 +，也可能选择 StringBuilder 或 StringBuffer。它们在性能上究竟有何差别？在循环中拼接多个字符串时，哪种方式更高效？\n本文基于 JMH（Java Microbenchmark Harness）进行了系统性测试，并使用 GitHub Actions 在 Ubuntu 环境中实测了不同字符串拼接方式的性能。\n🧪 测试目标 比较以下三种拼接方式在高频场景下的性能差异：\n+ 操作符（语法糖，编译期转为 StringBuilder.append） StringBuilder.append StringBuffer.append 🧰 项目创建与配置（Maven） 1. 创建基础工程 1 2 3 4 5 mvn archetype:generate \\ -DgroupId=com.xinchentechnote \\ -DartifactId=string-jmh \\ -DarchetypeArtifactId=maven-archetype-quickstart \\ -DinteractiveMode=false 2. 配置 pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.openjdk.jmh\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jmh-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.37\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.openjdk.jmh\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jmh-generator-annprocess\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.37\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;17\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;17\u0026lt;/target\u0026gt; \u0026lt;annotationProcessorPaths\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;org.openjdk.jmh\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jmh-generator-annprocess\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.37\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;/annotationProcessorPaths\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 📄 测试代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package com.xinchentechnote; import org.openjdk.jmh.annotations.*; import java.util.concurrent.TimeUnit; @BenchmarkMode({Mode.Throughput, Mode.AverageTime}) @OutputTimeUnit(TimeUnit.MICROSECONDS) @State(Scope.Thread) public class StringConcatBenchmark { private String str1 = \u0026#34;Hello\u0026#34;; private String str2 = \u0026#34;World\u0026#34;; private String str3 = \u0026#34;Java\u0026#34;; private int count = 100; @Benchmark public String testStringBuilder() { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; count; i++) { sb.append(str1); sb.append(str2); sb.append(str3); } return sb.toString(); } @Benchmark public String testStringBuffer() { StringBuffer sb = new StringBuffer(); for (int i = 0; i \u0026lt; count; i++) { sb.append(str1); sb.append(str2); sb.append(str3); } return sb.toString(); } @Benchmark public String testStringPlus() { String result = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; count; i++) { result += str1; result += str2; result += str3; } return result; } } 🚀 GitHub Actions 自动化测试配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 name: JMH Benchmarks on: workflow_dispatch: jobs: benchmark: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: actions/setup-java@v3 with: distribution: temurin java-version: \u0026#39;17\u0026#39; cache: maven - run: mvn clean install -DskipTests - run: java -jar target/benchmarks.jar StringConcatBenchmark 📊 实测结果（Ubuntu + GitHub Actions） 📈 吞吐量测试（Throughput） 单位：每微秒执行的操作数（ops/us）\n方法 吞吐量 StringBuilder 0.478 ops/us StringBuffer 0.448 ops/us + 操作符 🚫 0.199 ops/us ⏱ 平均耗时测试（AverageTime） 单位：每次操作的平均耗时（us/op）\n方法 平均耗时 StringBuilder 2.021 us/op StringBuffer 2.237 us/op + 操作符 🚫 5.244 us/op 🔍 原理解析 StringBuilder：非线程安全但性能最好，推荐在循环中使用。 StringBuffer：线程安全但性能略低。 + 操作符：虽然直观，但在循环中极其低效，会频繁创建临时对象，带来 GC 压力。 ✅ 使用建议 拼接方式 优点 缺点 推荐场景 StringBuilder 性能最佳 非线程安全 单线程高频拼接 StringBuffer 线程安全 性能略差 多线程拼接场景 + 操作符 简洁直观 慢且 GC 压力大 低频简易拼接 🏁 总结 本次 JMH 实测验证了开发经验中的最佳实践：在高频场景中，推荐使用 StringBuilder 进行字符串拼接。\n💡 JMH 小知识：Java 微基准测试利器 JMH (Java Microbenchmark Harness) 是由 Oracle 和 OpenJDK 团队专为 Java 编写的微基准测试框架，用于衡量 Java 方法在纳秒到微秒级别的性能表现。JMH 特别适用于需要精细分析方法调用开销、编译优化、副作用等对性能影响的场景。\n核心术语与注解解释： 注解或参数 含义 @Benchmark 标记要被测试的方法。每次运行都调用它并收集性能数据。 @BenchmarkMode 设置基准测试的模式（如吞吐量、平均时间等）。可选值包括：- Throughput: 单位时间内操作次数- AverageTime: 每个操作平均耗时- SampleTime, SingleShotTime, AllModes @OutputTimeUnit 设置输出结果的时间单位，如 TimeUnit.MILLISECONDS 或 MICROSECONDS。 @State 用于管理基准方法所需的状态变量作用域。常用 Scope.Thread 表示每线程独立状态。 @Fork 设置执行几轮 JVM 启动来规避 JVM 热身阶段的影响，通常设置为 1~3。 @Warmup 预热次数与每次持续时间（JIT 编译优化发生在此阶段）。避免冷启动影响基准数据。 @Measurement 真正采集性能数据的次数和持续时间。建议至少 5 次 × 1s+。 推荐配置参数说明： 1 2 3 4 5 6 @BenchmarkMode({Mode.Throughput, Mode.AverageTime}) // 同时测吞吐量和平均耗时 @OutputTimeUnit(TimeUnit.MICROSECONDS) // 输出微秒为单位 @State(Scope.Thread) // 每个线程独立状态 @Fork(1) // 启动 1 次 JVM @Warmup(iterations = 5, time = 1) // 预热 5 次，每次 1 秒 @Measurement(iterations = 5, time = 1) // 采样 5 次，每次 1 秒 为什么不能简单用 System.currentTimeMillis？ 因为 JVM 启动初期 JIT 编译未完成、内联尚未展开、逃逸分析等优化机制尚未介入，初始运行的耗时非常不稳定。而 JMH 通过：\n自动 warm-up 预热阶段；\n多轮 fork JVM 隔离优化影响；\n统计误差和波动范围（Error）；\n确保了测得结果更真实、更接近应用实际表现。\n希望本文能为你在日常开发与性能优化中提供量化参考！\n","date":"2025-05-11T10:29:30+08:00","permalink":"https://xinchentechnote.github.io/note/p/java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%80%A7%E8%83%BD%E5%AE%9E%E6%B5%8B%E5%9F%BA%E4%BA%8E-jmh-%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/","title":"Java 字符串拼接性能实测：基于 JMH 的微基准测试"}]