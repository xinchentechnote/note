[{"content":"C++ 二进制阅读器设计模式总结 本文从设计模式角度对一个基于 C++ 的二进制数据阅读器核心模块进行拆解和归纳，详细介绍了如何通过单例、工厂、策略、备忘录、模板与类型特征等模式，使得代码在扩展性、可维护性和灵活性方面达到最优。文末附有一张可在 GitHub 上直接渲染的 Mermaid 类图，帮助直观理解各模块之间的关系。\n目录 设计模式概览 1.1 单例模式（Singleton） 1.2 工厂模式（Factory） 1.3 策略模式（Strategy） 1.4 备忘录模式（Memento） 1.5 模板与类型特征（Template \u0026amp; Traits） 各模块与模式对应关系 Mermaid 类图 整体架构与总结 设计模式概览 单例模式（Singleton） 意图：保证一个类只有一个实例，并提供一个全局访问点。 应用场景：全局类型注册器、全局读取器工厂等需要共享状态的场景。 在本项目里，以下两个类被设计为单例：\nTypeFactory：维护“类型名称（如 \u0026quot;u8\u0026quot;、\u0026quot;i16\u0026quot;）→ std::type_index”的映射。 ReaderFactory：维护“读取类型名称（如 \u0026quot;u8\u0026quot;、\u0026quot;string@u8\u0026quot;）→ 对应的 ReaderStrategy 实例” 的映射。 典型实现示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // TypeFactory.hpp class TypeFactory { public: static TypeFactory\u0026amp; instance() { static TypeFactory inst; // 局部静态变量，C++11 及以后保证线程安全 return inst; } // 删除拷贝/赋值操作符，防止复制 TypeFactory(const TypeFactory\u0026amp;) = delete; TypeFactory\u0026amp; operator=(const TypeFactory\u0026amp;) = delete; std::type_index getTypeIndex(const std::string\u0026amp; shortName) const { … } template\u0026lt;typename T\u0026gt; static std::string getTypeShortName() { return TypeTraits\u0026lt;T\u0026gt;::short_name(); } // … private: TypeFactory(); // 私有构造，内部完成所有类型注册 ~TypeFactory(); // 私有析构 std::unordered_map\u0026lt;std::string, std::type_index\u0026gt; type_map_; }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // ReaderFactory.hpp class ReaderFactory { public: static ReaderFactory\u0026amp; instance() { static ReaderFactory inst; // 同样利用局部静态变量保证线程安全 return inst; } // 删除拷贝/赋值操作符 ReaderFactory(const ReaderFactory\u0026amp;) = delete; ReaderFactory\u0026amp; operator=(const ReaderFactory\u0026amp;) = delete; bool read(AppState\u0026amp; state, const std::string\u0026amp; typeName) const { auto it = readers_.find(typeName); if (it != readers_.end()) { return it-\u0026gt;second-\u0026gt;read(state, typeName); } return false; } private: ReaderFactory(); // 私有构造，内部注册所有 ReaderStrategy ~ReaderFactory(); std::unordered_map\u0026lt;std::string, std::unique_ptr\u0026lt;ReaderStrategy\u0026gt;\u0026gt; readers_; template\u0026lt;typename T\u0026gt; void emplaceReader(const std::string\u0026amp; shortName) { readers_.emplace(shortName, std::make_unique\u0026lt;TypedReader\u0026lt;T\u0026gt;\u0026gt;()); } }; 要点\n私有构造/析构、删除拷贝与赋值，确保只能通过 instance() 获取实例。 C++11 后，局部静态变量的初始化线程安全，无需额外加锁。 单例中持有全局共享的数据（如映射表），只会被创建一次，降低运行时开销。 工厂模式（Factory） 意图：将对象的创建与使用解耦，让“谁来创建对象”和“如何创建对象”的逻辑全部集中到一个或几个工厂类里。\n应用场景：\n新增或修改支持的基础类型时，只需在工厂里注册/修改相关逻辑； 客户端无需直接 new 某个类型，而是统一通过“类型名称 → 工厂”来获取实例。 1.2.1 TypeFactory 作用：完成“类型名称 → std::type_index”的映射与查询。\n内部维护：\n1 std::unordered_map\u0026lt;std::string, std::type_index\u0026gt; type_map_; 构造函数中批量注册所有基础类型：\n1 2 3 4 5 6 TypeFactory::TypeFactory() { type_map_.emplace(\u0026#34;u8\u0026#34;, typeid(uint8_t)); type_map_.emplace(\u0026#34;i16\u0026#34;, typeid(int16_t)); type_map_.emplace(\u0026#34;f32\u0026#34;, typeid(float)); // …更多类型注册… } 对外提供：\n1 2 std::type_index getTypeIndex(const std::string\u0026amp; shortName) const; template\u0026lt;typename T\u0026gt; static std::string getTypeShortName() { return TypeTraits\u0026lt;T\u0026gt;::short_name(); } 1.2.2 ReaderFactory 作用：完成“类型名称 → ReaderStrategy 实例” 的映射与查询。\n内部维护：\n1 std::unordered_map\u0026lt;std::string, std::unique_ptr\u0026lt;ReaderStrategy\u0026gt;\u0026gt; readers_; 构造函数中注册各种读取策略：\n1 2 3 4 5 6 7 8 9 10 11 ReaderFactory::ReaderFactory() { // 注册基础整数/浮点类型读取器 emplaceReader\u0026lt;uint8_t\u0026gt;(\u0026#34;u8\u0026#34;); emplaceReader\u0026lt;int16_t\u0026gt;(\u0026#34;i16\u0026#34;); emplaceReader\u0026lt;float\u0026gt;(\u0026#34;f32\u0026#34;); // 注册固定长度字符串读取器，例如 \u0026#34;string@8\u0026#34;：读取 8 字节 C 风格字符串 readers_.emplace(\u0026#34;string@8\u0026#34;, std::make_unique\u0026lt;FixStringReader\u0026gt;(8)); // 注册长度前缀字符串读取器，例如 \u0026#34;string@u16\u0026#34;：先读一个 uint16_t 作为长度，再读后续字节 readers_.emplace(\u0026#34;string@u16\u0026#34;, std::make_unique\u0026lt;LengthPrefixedStringReader\u0026lt;uint16_t\u0026gt;\u0026gt;()); // …更多注册… } 对外提供：\n1 2 3 4 5 6 7 bool read(AppState\u0026amp; state, const std::string\u0026amp; typeName) const { auto it = readers_.find(typeName); if (it != readers_.end()) { return it-\u0026gt;second-\u0026gt;read(state, typeName); } return false; } 要点\n将不同类型的“读取逻辑”注册到同一个映射表 readers_ 中； 客户端只需调用 ReaderFactory::instance().read(state, typeName) 即可，无需关心内部具体实现； 新增读取类型时，只要实现新的 ReaderStrategy 并在构造中注册即可，符合开闭原则。 策略模式（Strategy） 意图：定义一系列可互换的算法（策略），使它们可以独立于使用它们的客户端而变化。 应用场景：读取不同类型的数据（基础整数/浮点、固定长度字符串、长度前缀字符串）本质上就是不同的“读取算法”，统一使用相同接口即可实现动态切换。 1.3.1 抽象策略接口：ReaderStrategy 1 2 3 4 5 6 // ReaderStrategy.hpp class ReaderStrategy { public: virtual ~ReaderStrategy() = default; virtual bool read(AppState\u0026amp; state, std::string typeName) const = 0; }; 核心方法：bool read(AppState\u0026amp; state, std::string typeName) const，接收当前应用状态 AppState 和待读取数据的“类型名称”，返回是否读取成功，同时在内部更新 AppState（游标位置、状态消息、历史记录等）。 1.3.2 具体策略 TypedReader\n用于读取定长的基础类型（如 uint8_t、int16_t、float 等）。\n通过模板参数 T，在 read() 中调用：\n1 2 3 4 5 T value = state.read\u0026lt;T\u0026gt;(state.getCursorPos()); state.setStatusMsg(fmt::format(\u0026#34;Read {}: {} @ 0x{:X}\u0026#34;, Utils::format_value(value), state.getCursorPos())); return true; 在 ReaderFactory 中使用 emplaceReader\u0026lt;uint8_t\u0026gt;(\u0026quot;u8\u0026quot;)、emplaceReader\u0026lt;int16_t\u0026gt;(\u0026quot;i16\u0026quot;) 等来注册。\nFixStringReader\n用于读取“固定长度的 C 风格字符串”，构造时传入一个 size_t length。\nread() 的实现类似：\n1 2 3 4 5 std::string value = state.read_fixed_string(state.getCursorPos(), length_); state.setStatusMsg(fmt::format(\u0026#34;Read {}: {} @ 0x{:X}\u0026#34;, Utils::format_value(value), state.getCursorPos())); return true; LengthPrefixedStringReader\n用于读取“长度前缀字符串”，模板参数 LengthType（如 uint8_t、uint16_t、uint32_t 等）代表前缀所占字节数。 read() 先调用 state.read\u0026lt;LengthType\u0026gt;(pos) 得到字符串长度 N，再继续读取 N 字节作为实际字符串，更新状态并记录历史。 要点\n各个读取逻辑继承自同一个 ReaderStrategy 接口； 在工厂中统一注册（readers_[\u0026quot;u8\u0026quot;] → TypedReader\u0026lt;uint8_t\u0026gt;、readers_[\u0026quot;string@u8\u0026quot;] → LengthPrefixedStringReader\u0026lt;uint8_t\u0026gt; 等），客户端只需传入不同的 typeName，工厂便会选择对应策略执行； 新增一种读取逻辑（例如“变长压缩整数”），只要实现新的 ReaderStrategy 子类并在 ReaderFactory 构造中注册即可，无需改动其它业务代码。 备忘录模式（Memento） 意图：在不破坏封装性的前提下，捕获并保存一个对象的内部状态，以便在以后恢复。 应用场景：用户在任意时刻可以“撤销”最近一次读取，需要记录每次读取前的游标位置与读取到的数据值。 1.4.1 备忘录类：Record 1 2 3 4 5 6 7 8 9 10 11 // Record.hpp struct Record { size_t index; // 读取前的光标位置 std::any data; // 读取到的值（任意类型） std::string type_name; // 记录类型的名称，便于展示或日志 Record(size_t idx, std::any d, const std::string\u0026amp; t) : index(idx), data(std::move(d)), type_name(t) {} std::string description() const { return fmt::format(\u0026#34;{} @ 0x{:X}\u0026#34;, type_name, index); } }; 职责：在“读操作”发生时，先将当前光标 index、读取到的数据（封装为 std::any）以及对应的类型名称一起打包成一个 Record，压入 AppState::read_history 栈中。 1.4.2 原发器：AppState 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // AppState.hpp class AppState { public: AppState(const std::vector\u0026lt;uint8_t\u0026gt;\u0026amp; data) : data_(data) {} template\u0026lt;typename T\u0026gt; T peek(size_t pos) const { // 从 data_ 中读取 sizeof(T) 字节并根据小端或大端转换为 T T value = 0; for (size_t i = 0; i \u0026lt; sizeof(T); ++i) { value |= (T(data_[pos + i]) \u0026lt;\u0026lt; (8 * i)); // 假设小端字节序 } return value; } template\u0026lt;typename T\u0026gt; T read(size_t pos) { T value = peek\u0026lt;T\u0026gt;(pos); // 在读取前先保存一份“备忘录”到 read_history Record record{pos, value, TypeFactory::getTypeShortName\u0026lt;T\u0026gt;()}; read_history.push(std::move(record)); // 将游标往前移动 sizeof(T) 个字节 cursor_pos_ = pos + sizeof(T); status_msg_ = fmt::format(\u0026#34;Read {}: {} @ 0x{:X}\u0026#34;, Utils::format_value(value), pos); return value; } std::string read_fixed_string(size_t pos, size_t length) { std::string s(reinterpret_cast\u0026lt;const char*\u0026gt;(\u0026amp;data_[pos]), length); Record record{pos, s, fmt::format(\u0026#34;string@{}\u0026#34;, length)}; read_history.push(std::move(record)); cursor_pos_ = pos + length; status_msg_ = fmt::format(\u0026#34;Read {}: {} @ 0x{:X}\u0026#34;, Utils::format_value(s), pos); return s; } template\u0026lt;typename LengthType\u0026gt; std::string read_length_prefixed_string(size_t pos) { LengthType len = read\u0026lt;LengthType\u0026gt;(pos); // 递归调用 read\u0026lt;T\u0026gt;，也会记录备忘录 size_t strPos = pos + sizeof(LengthType); std::string s(reinterpret_cast\u0026lt;const char*\u0026gt;(\u0026amp;data_[strPos]), len); Record record{pos, s, fmt::format(\u0026#34;string@{}\u0026#34;, TypeFactory::getTypeShortName\u0026lt;LengthType\u0026gt;())}; read_history.push(std::move(record)); cursor_pos_ = strPos + len; status_msg_ = fmt::format(\u0026#34;Read {}: {} @ 0x{:X}\u0026#34;, Utils::format_value(s), pos); return s; } void undo() { if (!read_history.empty()) { Record record = read_history.top(); read_history.pop(); cursor_pos_ = record.index; // 恢复到读取前的光标位置 status_msg_ = fmt::format(\u0026#34;Undo to {}\u0026#34;, record.description()); } } size_t getCursorPos() const { return cursor_pos_; } void setCursorPos(size_t pos) { cursor_pos_ = pos; } std::string getStatusMsg() const { return status_msg_; } std::stack\u0026lt;Record\u0026gt; getReadHistory() const { return read_history; } private: std::vector\u0026lt;uint8_t\u0026gt; data_; // 待解析的二进制数据 size_t cursor_pos_ = 0; // 当前光标位置 std::string status_msg_; // 最近一次操作的状态消息 std::stack\u0026lt;Record\u0026gt; read_history; }; 要点\nAppState 同时扮演了“原发器（Originator）”和“管理者（Caretaker）”的角色； 每次 read\u0026lt;T\u0026gt;、read_fixed_string()、read_length_prefixed_string() 都会先将当前状态封装到 Record，再执行真正的读取操作； undo() 从堆栈顶弹出最近的 Record，并恢复 cursor_pos_，达到“撤销最近一次读取”的效果； 通过调用 getReadHistory() 可以获取整个读取历史栈，便于日志输出或调试。 模板与类型特征（Template \u0026amp; Traits） 意图：\n利用 C++ 模板生成对不同基础类型（如 uint8_t、int16_t、float 等）的通用读取逻辑，减少重复代码； 通过“类型特征（Traits）”在编译期将类型与它们对应的名称绑定，方便在程序运行时取得相应字符串。 1.5.1 类型特征：TypeTraits\u0026lt;T\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // TypeTraits.hpp template \u0026lt;typename T\u0026gt; struct TypeTraits; // 偏特化：uint8_t template \u0026lt;\u0026gt; struct TypeTraits\u0026lt;uint8_t\u0026gt; { static std::string name() { return \u0026#34;unsigned 8-bit integer\u0026#34;; } static std::string short_name() { return \u0026#34;u8\u0026#34;; } }; // 偏特化：int16_t template \u0026lt;\u0026gt; struct TypeTraits\u0026lt;int16_t\u0026gt; { static std::string name() { return \u0026#34;signed 16-bit integer\u0026#34;; } static std::string short_name() { return \u0026#34;i16\u0026#34;; } }; // 偏特化：float template \u0026lt;\u0026gt; struct TypeTraits\u0026lt;float\u0026gt; { static std::string name() { return \u0026#34;32-bit floating point\u0026#34;; } static std::string short_name() { return \u0026#34;f32\u0026#34;; } }; // …其他基础类型的特化… 对外接口：\n1 2 3 4 template\u0026lt;typename T\u0026gt; std::string TypeFactory::getTypeShortName() { return TypeTraits\u0026lt;T\u0026gt;::short_name(); } 1.5.2 AppState::peek\u0026lt;T\u0026gt;() 与 read\u0026lt;T\u0026gt;() peek\u0026lt;T\u0026gt;(pos)：\n从 data_ 中读取 sizeof(T) 字节并根据小端或大端转换为类型 T。 只做“查看”不修改光标。 read\u0026lt;T\u0026gt;(pos)：\n调用 peek\u0026lt;T\u0026gt;(pos) 获取值； 将 (pos, value, 类型名称) 封装成 Record 并压入 read_history； 将 cursor_pos_ 往前移动 sizeof(T) 字节； 更新 status_msg_ 并返回 value。 利用模板，AppState::peek\u0026lt;T\u0026gt; / AppState::read\u0026lt;T\u0026gt; 对不同基础类型无需写分支，统一由编译器根据 T 自动生成对应代码。\n各模块与模式对应关系 模块 / 类 设计模式 说明 TypeFactory Singleton + Factory 单例：全局只维护一份“类型映射”。\n工厂：完成“类型名 → std::type_index” 的注册与查询。 ReaderFactory Singleton + Factory 单例：全局只维护一份“读取器映射”。\n工厂：完成“类型名 → ReaderStrategy” 的注册与查询。 ReaderStrategy Strategy 算法接口：定义 bool read(AppState\u0026amp;, std::string)； TypedReader\u0026lt;T\u0026gt; Strategy + Template 具体策略：读取基础类型 T。模板化：根据 T 不同自动生成不同的读取逻辑。 FixStringReader Strategy 具体策略：读取固定长度的 C 字符串。构造时传入固定长度 length。 LengthPrefixedStringReader\u0026lt;LengthType\u0026gt; Strategy + Template 具体策略：读取“长度前缀字符串（LengthType 表示前缀宽度）”。 AppState Memento + Template 原发器 \u0026amp; 管理者：每次读取前将状态封装成 Record 存入栈；支持 peek\u0026lt;T\u0026gt;()、read\u0026lt;T\u0026gt;()、undo()。模板化读取减少重复。 Record Memento 备忘录：保存“读取前的光标位置 + 读取到的数据 + 类型名称”，由 AppState 在每次读取时创建并压入 read_history 栈中；undo() 时弹出并恢复。 TypeTraits\u0026lt;T\u0026gt; Traits 类型特征：在编译期将基础类型 T 与其“标准名称（name）”和“简短名称（short_name）”关联，为 TypeFactory 提供映射支持。 其他辅助 RAII / STL 容器 / 智能指针 代码中大量使用 std::unique_ptr\u0026lt;ReaderStrategy\u0026gt;、std::vector\u0026lt;uint8_t\u0026gt;、std::stack\u0026lt;Record\u0026gt; 等，均遵循 RAII 思想，无需手动管理内存。 Mermaid 类图 下面是一张以 Mermaid 语法编写的类图，将各主要类及其关系直观展现。只需将以下代码块复制到 GitHub 仓库的 Markdown 文件中即可自动渲染：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 classDiagram %% ================================ %% 单例工厂：TypeFactory %% ================================ class TypeFactory { \u0026lt;\u0026lt;Singleton\u0026gt;\u0026gt; - std::unordered_map\u0026lt;std::string, std::type_index\u0026gt; type_map_ + static TypeFactory\u0026amp; instance() + std::type_index getTypeIndex(const std::string\u0026amp; shortName) const + template\u0026lt;typename T\u0026gt; static std::string getTypeShortName() } %% ================================ %% 单例工厂：ReaderFactory %% ================================ class ReaderFactory { \u0026lt;\u0026lt;Singleton\u0026gt;\u0026gt; - std::unordered_map\u0026lt;std::string, ReaderStrategy*\u0026gt; readers_ + static ReaderFactory\u0026amp; instance() + bool read(AppState\u0026amp; state, const std::string\u0026amp; typeName) const + template\u0026lt;typename T\u0026gt; void emplaceReader(const std::string\u0026amp; shortName) } %% ================================ %% 策略接口：ReaderStrategy %% ================================ class ReaderStrategy { \u0026lt;\u0026lt;Interface\u0026gt;\u0026gt; \u0026lt;\u0026lt;abstract\u0026gt;\u0026gt; + virtual bool read(AppState\u0026amp; state, std::string typeName) const = 0 } %% ================================ %% 具体策略：TypedReader\u0026lt;T\u0026gt; %% ================================ class TypedReader~T~ { + bool read(AppState\u0026amp; state, std::string typeName) const } %% ================================ %% 具体策略：FixStringReader %% ================================ class FixStringReader { - size_t length_ + FixStringReader(size_t len) + bool read(AppState\u0026amp; state, std::string typeName) const } %% ================================ %% 具体策略：LengthPrefixedStringReader\u0026lt;LengthType\u0026gt; %% ================================ class LengthPrefixedStringReader~LengthType~ { + bool read(AppState\u0026amp; state, std::string typeName) const } %% ================================ %% AppState 与 备忘录：Record %% ================================ class AppState { - size_t cursor_pos_ - std::stack~Record~ read_history + template\u0026lt;typename T\u0026gt; T peek(size_t pos) const + template\u0026lt;typename T\u0026gt; T read(size_t pos) + void undo() + size_t getCursorPos() const + void setCursorPos(size_t pos) + std::string getStatusMsg() const } class Record { - size_t index - std::any data - std::string type_name + Record(size_t idx, std::any d, const std::string\u0026amp; t) + std::string description() const } %% ================================ %% 类型特征：TypeTraits\u0026lt;T\u0026gt; %% ================================ class TypeTraits~T~ { \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; + static std::string name() + static std::string short_name() } %% ================================ %% 类之间关系 %% ================================ TypeFactory --\u0026gt; \u0026#34;uses\u0026#34; TypeTraits~T~ ReaderFactory --\u0026gt; ReaderStrategy : maintains \u0026gt; ReaderFactory --\u0026gt; TypeFactory : uses \u0026gt; TypedReader~T~ ..|\u0026gt; ReaderStrategy : implements FixStringReader ..|\u0026gt; ReaderStrategy : implements LengthPrefixedStringReader~LengthType~ ..|\u0026gt; ReaderStrategy : implements AppState --\u0026gt; Record : writes to \u0026gt; AppState --\u0026gt; ReaderFactory : calls \u0026gt; Record ..|\u0026gt; Memento : (pattern role) 说明：\n\u0026lt;\u0026lt;Singleton\u0026gt;\u0026gt; 表示单例类； \u0026lt;\u0026lt;Interface\u0026gt;\u0026gt; 表示策略接口； 模板类用 ~T~ 或 ~LengthType~ 表示泛型参数； 箭头 --\u0026gt; 表示依赖或使用关系； 实线半空心箭头 ..|\u0026gt; 表示继承或实现关系； Memento 仅作模式角色标注，无对应实际 C++ 类。 整体架构与总结 解耦与可扩展\n通过 单例 + 工厂模式，将“类型注册”、“读取器注册”、“具体读取逻辑”集中管理：\n要新增基础类型，只需在 TypeFactory 中注册； 要新增读取方式，只需继承 ReaderStrategy 并在 ReaderFactory 注册。 客户端（通常是 UI 或命令行解析）只需调用：\n1 bool ok = ReaderFactory::instance().read(state, typeName); 即可完成从字节流中解析“类型为 typeName 的数据”。整个流程对客户端透明，无需了解内部实现细节。\n可撤销的读取（Undo）\n通过 备忘录模式，每次读取前将当前光标位置和将要读取的数据值打包成 Record 并压入栈中。 用户若需撤销，只需调用 AppState::undo()，即可将光标回退到上一次读取前的位置，并在状态消息里提示 “Undo to …”。 可以轻松扩展为多级撤销、Redo（只需另维护一个“重做栈”）等。 模板与类型特征\nTypeTraits\u0026lt;T\u0026gt; 在编译期将 T 与其名称绑定，配合 TypeFactory 实现“类型名称 ↔ typeid” 的双向映射。 AppState::peek\u0026lt;T\u0026gt;() / read\u0026lt;T\u0026gt;() 与 TypedReader\u0026lt;T\u0026gt;，利用模板自动生成不同数据宽度的读取代码，避免了手写大量类似的函数。 如果需要在不同字节序（小端/大端）之间切换，只需在 peek\u0026lt;T\u0026gt;() 内添加条件分支或再提供另一个 EndianTraits 即可。 整体调用流程示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 假设 dataVec 存放了待解析的二进制数据 AppState state(dataVec); // 用户想读取一个 16 位带符号整数 (i16)： if (ReaderFactory::instance().read(state, \u0026#34;i16\u0026#34;)) { std::cout \u0026lt;\u0026lt; state.getStatusMsg() \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;无法解析类型 i16\u0026#34; \u0026lt;\u0026lt; std::endl; } // 继续读取一个长度前缀字符串 (string@u16)： if (ReaderFactory::instance().read(state, \u0026#34;string@u16\u0026#34;)) { std::cout \u0026lt;\u0026lt; state.getStatusMsg() \u0026lt;\u0026lt; std::endl; } // 如果发生了误操作，用户想撤销最近一次读取： state.undo(); std::cout \u0026lt;\u0026lt; state.getStatusMsg() \u0026lt;\u0026lt; std::endl; // 输出类似 \u0026#34;Undo to i16 @ 0x02\u0026#34; 优势与扩展思路\n新增类型/读取方式：在 TypeFactory 或 ReaderFactory 中添加注册逻辑即可，无需改动客户端调用。 支持更多复杂读取：如果想读取压缩整数（varint）、位域（bitfield）或自定义协议，只需新建子类继承 ReaderStrategy，并在工厂里注册。 可重做（Redo）功能：只要在 undo() 中将弹出的 Record 同时推入一个“重做栈”，再实现 redo() 即可。 可视化/调试：通过 AppState::getReadHistory() 获取完整的读取记录栈，可输出到日志或在 GUI 中展示。 跨平台字节序：如果需要兼容大端机器，可在 peek\u0026lt;T\u0026gt;() 中根据运行时判断或模板参数做相应调整。 本文所有代码示例均可在 C++11 以上版本下编译运行。 若使用更高版本（C++17、C++20），可结合 std::byte、std::variant、std::optional 等特性，进一步优化类型安全和可读性。\n作者：xinchen 首次发布日期：2025-05-25 版权所有 © 2025 作者信息：af83f787e8911dea9b3bf677746ebac9\n","date":"2025-05-25T21:20:23+08:00","permalink":"https://xinchentechnote.github.io/note/p/c-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%80/","title":"C++设计模式一"},{"content":"基于python的struct模块实现简单的ByteBuf 写在前面 在网络编程中需要将消息序列化为二进制序列打包传输。python标准库中的struct模块提供了pack、unpack等函数将基本数据类型转换为对应的bytes数组。使用pack、unpack需要在传参是需要关注字节序（大小端）、格式等，其中字节序有@、=、\u0026lt;、\u0026gt;、！五种，格式约21种，使用成本相对高。所以参考Netty的ByteBuf及Rust的bytes库中的Buf、BufMut为Python简单封装一个类似的ByteBuf。\nnetty中ByteBuf的基本结构如下：\n1 2 3 4 5 6 +-------------------+------------------+------------------+ | discardable bytes | readable bytes | writable bytes | | | (CONTENT) | | +-------------------+------------------+------------------+ | | | | 0 \u0026lt;= readerIndex \u0026lt;= writerIndex \u0026lt;= capacity 一、Buf接口设计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 import abc import struct from numpy import longlong \u0026#34;\u0026#34;\u0026#34; https://netty.io/4.0/api/io/netty/buffer/ByteBuf.html https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html https://docs.rs/bytes/1.1.0/bytes/ \u0026#34;\u0026#34;\u0026#34; class Buf(metaclass=abc.ABCMeta): class ByteOrder: NATIVE = \u0026#39;@\u0026#39; STD_NATIVE = \u0026#39;=\u0026#39; LITTLE_ENDIAN = \u0026#39;\u0026lt;\u0026#39; BIG_ENDIAN = \u0026#39;\u0026gt;\u0026#39; NETWORK = \u0026#39;!\u0026#39; PAD_BYTE = \u0026#39;x\u0026#39; CHAR = \u0026#39;c\u0026#39; SIGNED_CHAR = \u0026#39;b\u0026#39; UNSIGNED_CHAR = \u0026#39;B\u0026#39; BOOLEAN = \u0026#39;?\u0026#39; SHORT = \u0026#39;h\u0026#39; UNSIGNED_SHORT = \u0026#39;H\u0026#39; INT = \u0026#39;i\u0026#39; UNSIGNED_INT = \u0026#39;I\u0026#39; LONG = \u0026#39;l\u0026#39; UNSIGNED_LONG = \u0026#39;L\u0026#39; LONG_LONG = \u0026#39;q\u0026#39; UNSIGNED_LONG_LONG = \u0026#39;Q\u0026#39; SSIZE_T = \u0026#39;n\u0026#39; SIZE_T = \u0026#39;N\u0026#39; EXPONENT = \u0026#39;e\u0026#39; FLOAT = \u0026#39;f\u0026#39; DOUBLE = \u0026#39;d\u0026#39; CHAR_ARR = \u0026#39;s\u0026#39; CHAR_ARR1 = \u0026#39;p\u0026#39; VOID = \u0026#39;P\u0026#39; @abc.abstractmethod def readable_bytes_len(self) -\u0026gt; int: pass @abc.abstractmethod def to_bytes(self) -\u0026gt; bytearray: pass @abc.abstractmethod def write_i8(self, value: int): pass @abc.abstractmethod def write_u8(self, value: int): pass @abc.abstractmethod def write_bool(self, value: bool): pass @abc.abstractmethod def write_i16(self, value: int): pass @abc.abstractmethod def write_i16_le(self, value: int): pass @abc.abstractmethod def write_u16(self, value: int): pass @abc.abstractmethod def write_u16_le(self, value: int): pass @abc.abstractmethod def write_i32(self, value: int): pass @abc.abstractmethod def write_i32_le(self, value: int): pass @abc.abstractmethod def write_u32(self, value: int): pass @abc.abstractmethod def write_u32_le(self, value: int): pass @abc.abstractmethod def write_i64(self, value: longlong): pass @abc.abstractmethod def write_i64_le(self, value: longlong): pass @abc.abstractmethod def write_u64(self, value: longlong): pass @abc.abstractmethod def write_u64_le(self, value: longlong): pass @abc.abstractmethod def write_f32(self, value: float): pass @abc.abstractmethod def write_f32_le(self, value: float): pass @abc.abstractmethod def write_f64(self, value: float): pass @abc.abstractmethod def write_f64_le(self, value: float): pass @abc.abstractmethod def write_bytes(self, value: bytes): pass @abc.abstractmethod def read_i8(self): pass @abc.abstractmethod def read_u8(self): pass @abc.abstractmethod def read_bool(self): pass @abc.abstractmethod def read_i16(self): pass @abc.abstractmethod def read_i16_le(self): pass @abc.abstractmethod def read_u16(self): pass @abc.abstractmethod def read_u16_le(self): pass @abc.abstractmethod def read_i32(self): pass @abc.abstractmethod def read_i32_le(self): pass @abc.abstractmethod def read_u32(self): pass @abc.abstractmethod def read_u32_le(self): pass @abc.abstractmethod def read_i64(self): pass @abc.abstractmethod def read_i64_le(self): pass @abc.abstractmethod def read_u64(self): pass @abc.abstractmethod def read_u64_le(self): pass @abc.abstractmethod def read_f32(self): pass @abc.abstractmethod def read_f32_le(self): pass @abc.abstractmethod def read_f64(self): pass @abc.abstractmethod def read_f64_le(self): pass @abc.abstractmethod def read_bytes(self, length: int) -\u0026gt; bytes: pass 二、ByteBuf具体实现 ByteBuf底层使用可以字节数组bytearray作存储，记录分别读写的位置。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 import abc import struct from numpy import longlong class ByteBuf(Buf): def __init__(self, buf: bytearray = None) -\u0026gt; None: if buf is None: self.buf = bytearray() self.write_index = 0 else: self.buf = buf self.write_index = len(buf) self.read_index = 0 def check_readable_bytes_len(self, length: int): if self.readable_bytes_len() \u0026lt; length: raise Exception(\u0026#34;readable bytes length must greater than or equal %d\u0026#34; % length) def readable_bytes_len(self) -\u0026gt; int: return self.write_index - self.read_index def to_bytes(self) -\u0026gt; bytearray: return self.buf def write_i8(self, value: int): self.buf += struct.pack(Buf.SIGNED_CHAR, value) self.write_index += 1 def write_u8(self, value: int): self.buf += struct.pack(Buf.UNSIGNED_CHAR, value) self.write_index += 1 def write_bool(self, value: bool): self.buf += struct.pack(Buf.BOOLEAN, value) self.write_index += 1 def write_i16(self, value: int): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.SHORT, value) self.write_index += 2 def write_i16_le(self, value: int): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.SHORT, value) self.write_index += 2 def write_u16(self, value: int): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.UNSIGNED_SHORT, value) self.write_index += 2 def write_u16_le(self, value: int): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.UNSIGNED_SHORT, value) self.write_index += 2 def write_i32(self, value: int): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.INT, value) self.write_index += 4 def write_i32_le(self, value: int): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.INT, value) self.write_index += 4 def write_u32(self, value: int): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.UNSIGNED_INT, value) self.write_index += 4 def write_u32_le(self, value: int): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.UNSIGNED_INT, value) self.write_index += 4 def write_i64(self, value: longlong): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.LONG_LONG, value) self.write_index += 8 def write_i64_le(self, value: longlong): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.LONG_LONG, value) self.write_index += 8 def write_u64(self, value: longlong): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.UNSIGNED_LONG_LONG, value) self.write_index += 8 def write_u64_le(self, value: longlong): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.UNSIGNED_LONG_LONG, value) self.write_index += 8 def write_f32(self, value: float): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.FLOAT, value) self.write_index += 4 def write_f32_le(self, value: float): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.FLOAT, value) self.write_index += 4 def write_f64(self, value: float): self.buf += struct.pack(Buf.ByteOrder.BIG_ENDIAN + Buf.DOUBLE, value) self.write_index += 8 def write_f64_le(self, value: float): self.buf += struct.pack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.DOUBLE, value) self.write_index += 8 def write_bytes(self, value: bytes): if len(value) \u0026gt; 0: self.buf += value self.write_index += len(value) def read_i8(self) -\u0026gt; int: self.check_readable_bytes_len(1) ret = struct.unpack(Buf.SIGNED_CHAR, self.buf[self.read_index:self.read_index + 1]) self.read_index += 1 return ret[0] def read_u8(self): self.check_readable_bytes_len(1) ret = struct.unpack(Buf.UNSIGNED_CHAR, self.buf[self.read_index:self.read_index + 1]) self.read_index += 1 return ret[0] def read_bool(self): self.check_readable_bytes_len(1) ret = struct.unpack(Buf.BOOLEAN, self.buf[self.read_index:self.read_index + 1]) self.read_index += 1 return ret[0] def read_i16(self): self.check_readable_bytes_len(2) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.SHORT, self.buf[self.read_index:self.read_index + 2]) self.read_index += 2 return ret[0] def read_i16_le(self): self.check_readable_bytes_len(2) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.SHORT, self.buf[self.read_index:self.read_index + 2]) self.read_index += 2 return ret[0] def read_u16(self): self.check_readable_bytes_len(2) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.UNSIGNED_SHORT, self.buf[self.read_index:self.read_index + 2]) self.read_index += 2 return ret[0] def read_u16_le(self): self.check_readable_bytes_len(2) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.UNSIGNED_SHORT, self.buf[self.read_index:self.read_index + 2]) self.read_index += 2 return ret[0] def read_i32(self): ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.INT, self.buf[self.read_index:self.read_index + 4]) self.read_index += 4 return ret[0] def read_i32_le(self): self.check_readable_bytes_len(4) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.INT, self.buf[self.read_index:self.read_index + 4]) self.read_index += 4 return ret[0] def read_u32(self): self.check_readable_bytes_len(4) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.UNSIGNED_INT, self.buf[self.read_index:self.read_index + 4]) self.read_index += 4 return ret[0] def read_u32_le(self): self.check_readable_bytes_len(4) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.UNSIGNED_INT, self.buf[self.read_index:self.read_index + 4]) self.read_index += 4 return ret[0] def read_i64(self): self.check_readable_bytes_len(8) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.LONG_LONG, self.buf[self.read_index:self.read_index + 8]) self.read_index += 8 return ret[0] def read_i64_le(self): self.check_readable_bytes_len(8) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.LONG_LONG, self.buf[self.read_index:self.read_index + 8]) self.read_index += 8 return ret[0] def read_u64(self): self.check_readable_bytes_len(8) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.UNSIGNED_LONG_LONG, self.buf[self.read_index:self.read_index + 8]) self.read_index += 8 return ret[0] def read_u64_le(self): self.check_readable_bytes_len(8) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.UNSIGNED_LONG_LONG, self.buf[self.read_index:self.read_index + 8]) self.read_index += 8 return ret[0] def read_f32(self): self.check_readable_bytes_len(4) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.FLOAT, self.buf[self.read_index:self.read_index + 4]) self.read_index += 4 return ret[0] def read_f32_le(self): self.check_readable_bytes_len(4) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.FLOAT, self.buf[self.read_index:self.read_index + 4]) self.read_index += 4 return ret[0] def read_f64(self): self.check_readable_bytes_len(8) ret = struct.unpack(Buf.ByteOrder.BIG_ENDIAN + Buf.DOUBLE, self.buf[self.read_index:self.read_index + 8]) self.read_index += 8 return ret[0] def read_f64_le(self): self.check_readable_bytes_len(8) ret = struct.unpack(Buf.ByteOrder.LITTLE_ENDIAN + Buf.DOUBLE, self.buf[self.read_index:self.read_index + 8]) self.read_index += 8 return ret[0] def read_bytes(self, length: int) -\u0026gt; bytearray: self.check_readable_bytes_len(length) ret = self.buf[self.read_index:self.read_index + length] self.read_index += length return ret 三、编写单元测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 import os, sys sys.path.append(os.getcwd()) from unittest import TestCase import pytest from buf.byte_buf import ByteBuf class TestByteBuf(TestCase): def setUp(self) -\u0026gt; None: self.buf = ByteBuf() def test_byte_buf(self) -\u0026gt; int: self.buf.write_i8(127) self.buf.write_i8(127) self.buf.write_i8(1) self.buf.write_f32(1) buf1 = ByteBuf(self.buf.to_bytes()) self.assertEqual(7, buf1.readable_bytes_len()) def test_readable_bytes_len(self) -\u0026gt; int: self.buf.write_i8(127) self.buf.write_i8(127) self.buf.write_i8(1) self.buf.write_f32(1) self.assertEqual(7, self.buf.readable_bytes_len()) def test_to_bytes(self) -\u0026gt; bytes: self.buf.write_i8(127) self.buf.write_i8(127) self.buf.write_i8(1) self.assertEqual(b\u0026#39;\\x7f\\x7f\\x01\u0026#39;, self.buf.to_bytes()) def test_write_i8(self): self.buf.write_i8(-128) self.buf.write_i8(0) self.buf.write_i8(127) self.assertEqual(-128, self.buf.read_i8()) self.assertEqual(0, self.buf.read_i8()) self.assertEqual(127, self.buf.read_i8()) def test_write_i8_failed1(self): with pytest.raises(Exception): self.buf.write_i8(128) def test_write_i8_failed2(self): with pytest.raises(Exception): self.buf.write_i8(-129) def test_write_i8_failed3(self): with pytest.raises(Exception): self.buf.read_i8() def test_write_u8(self): self.buf.write_u8(0) self.buf.write_u8(127) self.buf.write_u8(255) self.assertEqual(0, self.buf.read_u8()) self.assertEqual(127, self.buf.read_u8()) self.assertEqual(255, self.buf.read_u8()) def test_write_u8_failed1(self): with pytest.raises(Exception): self.buf.write_u8(-1) def test_write_u8_failed2(self): with pytest.raises(Exception): self.buf.write_u8(256) def test_write_bool(self): self.buf.write_bool(True) self.buf.write_bool(False) self.buf.write_bool(1) self.buf.write_bool(0) self.buf.write_bool(22222) self.assertTrue(self.buf.read_bool()) self.assertFalse(self.buf.read_bool()) self.assertTrue(self.buf.read_bool()) self.assertFalse(self.buf.read_bool()) self.assertTrue(self.buf.read_bool()) def test_write_i16(self): self.buf.write_i16(-32768) self.buf.write_i16(0) self.buf.write_i16(127) self.buf.write_i16(32767) self.assertEqual(-32768, self.buf.read_i16()) self.assertEqual(0, self.buf.read_i16()) self.assertEqual(127, self.buf.read_i16()) self.assertEqual(32767, self.buf.read_i16()) def test_write_i16_failed1(self): with pytest.raises(Exception): self.buf.write_i16(-32769) def test_write_i16_failed2(self): with pytest.raises(Exception): self.buf.write_i16(32768) def test_write_i16_le(self): self.buf.write_i16_le(-32768) self.buf.write_i16_le(0) self.buf.write_i16_le(127) self.buf.write_i16_le(32767) self.buf.write_i16_le(32767) self.assertEqual(-32768, self.buf.read_i16_le()) self.assertEqual(0, self.buf.read_i16_le()) self.assertEqual(127, self.buf.read_i16_le()) self.assertEqual(32767, self.buf.read_i16_le()) self.assertNotEqual(32767, self.buf.read_i16()) def test_write_u16(self): self.buf.write_u16(0) self.buf.write_u16(127) self.buf.write_u16(65535) self.assertEqual(0, self.buf.read_u16()) self.assertEqual(127, self.buf.read_u16()) self.assertEqual(65535, self.buf.read_u16()) def test_write_u16_failed1(self): with pytest.raises(Exception): self.buf.write_u16(-1) def test_write_u16_failed2(self): with pytest.raises(Exception): self.buf.write_u16(65536) def test_write_u16_le(self): self.buf.write_u16_le(0) self.buf.write_u16_le(127) self.buf.write_u16_le(65535) self.buf.write_u16_le(65534) self.assertEqual(0, self.buf.read_u16_le()) self.assertEqual(127, self.buf.read_u16_le()) self.assertEqual(65535, self.buf.read_u16_le()) self.assertNotEqual(65534, self.buf.read_u16()) def test_write_i32(self): self.buf.write_i32(-2 ** 31) self.buf.write_i32(0) self.buf.write_i32(127) self.buf.write_i32(127) self.buf.write_i32(2 ** 31 - 1) self.assertEqual(-2 ** 31, self.buf.read_i32()) self.assertEqual(0, self.buf.read_i32()) self.assertEqual(127, self.buf.read_i32()) self.assertNotEqual(127, self.buf.read_i32_le()) self.assertEqual(2 ** 31 - 1, self.buf.read_i32()) def test_write_i32_le(self): self.buf.write_i32_le(-2 ** 31) self.buf.write_i32_le(0) self.buf.write_i32_le(127) self.buf.write_i32_le(127) self.buf.write_i32_le(2 ** 31 - 1) self.assertEqual(-2 ** 31, self.buf.read_i32_le()) self.assertEqual(0, self.buf.read_i32_le()) self.assertEqual(127, self.buf.read_i32_le()) self.assertNotEqual(127, self.buf.read_i32()) self.assertEqual(2 ** 31 - 1, self.buf.read_i32_le()) def test_write_u32(self): self.buf.write_u32(0) self.buf.write_u32(127) self.buf.write_u32(127) self.buf.write_u32(2 ** 32 - 1) self.assertEqual(0, self.buf.read_u32()) self.assertEqual(127, self.buf.read_u32()) self.assertNotEqual(127, self.buf.read_u32_le()) self.assertEqual(2 ** 32 - 1, self.buf.read_u32()) def test_write_u32_failed1(self): with pytest.raises(Exception): self.buf.write_u32(-1) def test_write_u32_failed2(self): with pytest.raises(Exception): self.buf.write_u32(2 ** 32) def test_write_u32_le(self): self.buf.write_u32_le(0) self.buf.write_u32_le(127) self.buf.write_u32_le(127) self.buf.write_u32_le(2 ** 32 - 1) self.assertEqual(0, self.buf.read_u32_le()) self.assertEqual(127, self.buf.read_u32_le()) self.assertNotEqual(127, self.buf.read_u32()) self.assertEqual(2 ** 32 - 1, self.buf.read_u32_le()) def test_write_i64(self): self.buf.write_i64(- 2 ** 63) self.buf.write_i64(0) self.buf.write_i64(127) self.buf.write_i64(127) self.buf.write_i64(2 ** 63 - 1) self.assertEqual(-2 ** 63, self.buf.read_i64()) self.assertEqual(0, self.buf.read_i64()) self.assertEqual(127, self.buf.read_i64()) self.assertNotEqual(127, self.buf.read_i64_le()) self.assertEqual(2 ** 63 - 1, self.buf.read_i64()) def test_write_i64_le(self): self.buf.write_i64_le(- 2 ** 63) self.buf.write_i64_le(0) self.buf.write_i64_le(127) self.buf.write_i64_le(127) self.buf.write_i64_le(2 ** 63 - 1) self.assertEqual(-2 ** 63, self.buf.read_i64_le()) self.assertEqual(0, self.buf.read_i64_le()) self.assertEqual(127, self.buf.read_i64_le()) self.assertNotEqual(127, self.buf.read_i64()) self.assertEqual(2 ** 63 - 1, self.buf.read_i64_le()) def test_write_u64(self): self.buf.write_i64_le(- 2 ** 63) self.buf.write_i64_le(0) self.buf.write_i64_le(127) self.buf.write_i64_le(127) self.buf.write_i64_le(2 ** 63 - 1) self.assertEqual(-2 ** 63, self.buf.read_i64_le()) self.assertEqual(0, self.buf.read_i64_le()) self.assertEqual(127, self.buf.read_i64_le()) self.assertNotEqual(127, self.buf.read_i64()) self.assertEqual(2 ** 63 - 1, self.buf.read_i64_le()) def test_write_u64_le(self): self.buf.write_u64_le(0) self.buf.write_u64_le(127) self.buf.write_u64_le(127) self.buf.write_u64_le(2 ** 64 - 1) self.assertEqual(0, self.buf.read_u64_le()) self.assertEqual(127, self.buf.read_u64_le()) self.assertNotEqual(127, self.buf.read_u64()) self.assertEqual(2 ** 64 - 1, self.buf.read_u64_le()) def test_write_f32(self): self.buf.write_f32(0) self.buf.write_f32(127) self.buf.write_f32(127) self.buf.write_f32(12.0) self.assertEqual(0, self.buf.read_f32()) self.assertEqual(127, self.buf.read_f32()) self.assertNotEqual(127, self.buf.read_f32_le()) self.assertEqual(12.0, self.buf.read_f32()) def test_write_f32_le(self): self.buf.write_f32_le(0) self.buf.write_f32_le(127) self.buf.write_f32_le(127) self.buf.write_f32_le(12.0) self.assertEqual(0, self.buf.read_f32_le()) self.assertEqual(127, self.buf.read_f32_le()) self.assertNotEqual(127, self.buf.read_f32()) self.assertEqual(12.0, self.buf.read_f32_le()) def test_write_f64(self): self.buf.write_f64(0) self.buf.write_f64(127) self.buf.write_f64(127) self.buf.write_f64(12.0) self.assertEqual(0, self.buf.read_f64()) self.assertEqual(127, self.buf.read_f64()) self.assertNotEqual(127, self.buf.read_f64_le()) self.assertEqual(12.0, self.buf.read_f64()) def test_write_f64_le(self): self.buf.write_f64_le(0) self.buf.write_f64_le(127) self.buf.write_f64_le(127) self.buf.write_f64_le(12.0) self.assertEqual(0, self.buf.read_f64_le()) self.assertEqual(127, self.buf.read_f64_le()) self.assertNotEqual(127, self.buf.read_f64()) self.assertEqual(12.0, self.buf.read_f64_le()) def test_write_bytes(self): self.buf.write_bytes(b\u0026#39;hello\u0026#39;) self.assertEqual(b\u0026#39;hel\u0026#39;, self.buf.read_bytes(3)) self.assertEqual(b\u0026#39;lo\u0026#39;, self.buf.read_bytes(2)) 执行单元测试\n1 2 3 buf\\test_byte_buf.py .................................. [100%] ============================================================================================= 34 passed in 0.60s ============================================================================================== 四、总结： 该ByteBuf不考虑线程安全，仅提供了顺序读写的能力，未来在实际使用过程中根据实际完善，比如随机读写能力，基于多个ByteBuf进行Wrapper组合构建新的ByteBuf等。\n参考文档：\nhttps://netty.io/4.0/api/io/netty/buffer/ByteBuf.html https://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html https://docs.rs/bytes/1.1.0/bytes/\n下期预告：基于Bytebuf实现对交易所交易接口消息的封装 ","date":"2025-05-11T18:29:30+08:00","permalink":"https://xinchentechnote.github.io/note/p/%E5%9F%BA%E4%BA%8Epython%E7%9A%84struct%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84bytebuf/","title":"基于python的struct模块实现简单的ByteBuf"},{"content":"Java 字符串拼接性能实测：基于 JMH 的微基准测试 在 Java 开发中，字符串拼接操作无处不在。你可能会直接使用 +，也可能选择 StringBuilder 或 StringBuffer。它们在性能上究竟有何差别？在循环中拼接多个字符串时，哪种方式更高效？\n本文基于 JMH（Java Microbenchmark Harness）进行了系统性测试，并使用 GitHub Actions 在 Ubuntu 环境中实测了不同字符串拼接方式的性能。\n🧪 测试目标 比较以下三种拼接方式在高频场景下的性能差异：\n+ 操作符（语法糖，编译期转为 StringBuilder.append） StringBuilder.append StringBuffer.append 🧰 项目创建与配置（Maven） 1. 创建基础工程 1 2 3 4 5 mvn archetype:generate \\ -DgroupId=com.xinchentechnote \\ -DartifactId=string-jmh \\ -DarchetypeArtifactId=maven-archetype-quickstart \\ -DinteractiveMode=false 2. 配置 pom.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.openjdk.jmh\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jmh-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.37\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.openjdk.jmh\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jmh-generator-annprocess\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.37\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;17\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;17\u0026lt;/target\u0026gt; \u0026lt;annotationProcessorPaths\u0026gt; \u0026lt;path\u0026gt; \u0026lt;groupId\u0026gt;org.openjdk.jmh\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jmh-generator-annprocess\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.37\u0026lt;/version\u0026gt; \u0026lt;/path\u0026gt; \u0026lt;/annotationProcessorPaths\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 📄 测试代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package com.xinchentechnote; import org.openjdk.jmh.annotations.*; import java.util.concurrent.TimeUnit; @BenchmarkMode({Mode.Throughput, Mode.AverageTime}) @OutputTimeUnit(TimeUnit.MICROSECONDS) @State(Scope.Thread) public class StringConcatBenchmark { private String str1 = \u0026#34;Hello\u0026#34;; private String str2 = \u0026#34;World\u0026#34;; private String str3 = \u0026#34;Java\u0026#34;; private int count = 100; @Benchmark public String testStringBuilder() { StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; count; i++) { sb.append(str1); sb.append(str2); sb.append(str3); } return sb.toString(); } @Benchmark public String testStringBuffer() { StringBuffer sb = new StringBuffer(); for (int i = 0; i \u0026lt; count; i++) { sb.append(str1); sb.append(str2); sb.append(str3); } return sb.toString(); } @Benchmark public String testStringPlus() { String result = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; count; i++) { result += str1; result += str2; result += str3; } return result; } } 🚀 GitHub Actions 自动化测试配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 name: JMH Benchmarks on: workflow_dispatch: jobs: benchmark: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: actions/setup-java@v3 with: distribution: temurin java-version: \u0026#39;17\u0026#39; cache: maven - run: mvn clean install -DskipTests - run: java -jar target/benchmarks.jar StringConcatBenchmark 📊 实测结果（Ubuntu + GitHub Actions） 📈 吞吐量测试（Throughput） 单位：每微秒执行的操作数（ops/us）\n方法 吞吐量 StringBuilder 0.478 ops/us StringBuffer 0.448 ops/us + 操作符 🚫 0.199 ops/us ⏱ 平均耗时测试（AverageTime） 单位：每次操作的平均耗时（us/op）\n方法 平均耗时 StringBuilder 2.021 us/op StringBuffer 2.237 us/op + 操作符 🚫 5.244 us/op 🔍 原理解析 StringBuilder：非线程安全但性能最好，推荐在循环中使用。 StringBuffer：线程安全但性能略低。 + 操作符：虽然直观，但在循环中极其低效，会频繁创建临时对象，带来 GC 压力。 ✅ 使用建议 拼接方式 优点 缺点 推荐场景 StringBuilder 性能最佳 非线程安全 单线程高频拼接 StringBuffer 线程安全 性能略差 多线程拼接场景 + 操作符 简洁直观 慢且 GC 压力大 低频简易拼接 🏁 总结 本次 JMH 实测验证了开发经验中的最佳实践：在高频场景中，推荐使用 StringBuilder 进行字符串拼接。\n💡 JMH 小知识：Java 微基准测试利器 JMH (Java Microbenchmark Harness) 是由 Oracle 和 OpenJDK 团队专为 Java 编写的微基准测试框架，用于衡量 Java 方法在纳秒到微秒级别的性能表现。JMH 特别适用于需要精细分析方法调用开销、编译优化、副作用等对性能影响的场景。\n核心术语与注解解释： 注解或参数 含义 @Benchmark 标记要被测试的方法。每次运行都调用它并收集性能数据。 @BenchmarkMode 设置基准测试的模式（如吞吐量、平均时间等）。可选值包括：- Throughput: 单位时间内操作次数- AverageTime: 每个操作平均耗时- SampleTime, SingleShotTime, AllModes @OutputTimeUnit 设置输出结果的时间单位，如 TimeUnit.MILLISECONDS 或 MICROSECONDS。 @State 用于管理基准方法所需的状态变量作用域。常用 Scope.Thread 表示每线程独立状态。 @Fork 设置执行几轮 JVM 启动来规避 JVM 热身阶段的影响，通常设置为 1~3。 @Warmup 预热次数与每次持续时间（JIT 编译优化发生在此阶段）。避免冷启动影响基准数据。 @Measurement 真正采集性能数据的次数和持续时间。建议至少 5 次 × 1s+。 推荐配置参数说明： 1 2 3 4 5 6 @BenchmarkMode({Mode.Throughput, Mode.AverageTime}) // 同时测吞吐量和平均耗时 @OutputTimeUnit(TimeUnit.MICROSECONDS) // 输出微秒为单位 @State(Scope.Thread) // 每个线程独立状态 @Fork(1) // 启动 1 次 JVM @Warmup(iterations = 5, time = 1) // 预热 5 次，每次 1 秒 @Measurement(iterations = 5, time = 1) // 采样 5 次，每次 1 秒 为什么不能简单用 System.currentTimeMillis？ 因为 JVM 启动初期 JIT 编译未完成、内联尚未展开、逃逸分析等优化机制尚未介入，初始运行的耗时非常不稳定。而 JMH 通过：\n自动 warm-up 预热阶段；\n多轮 fork JVM 隔离优化影响；\n统计误差和波动范围（Error）；\n确保了测得结果更真实、更接近应用实际表现。\n希望本文能为你在日常开发与性能优化中提供量化参考！\n","date":"2025-05-11T10:29:30+08:00","permalink":"https://xinchentechnote.github.io/note/p/java-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%80%A7%E8%83%BD%E5%AE%9E%E6%B5%8B%E5%9F%BA%E4%BA%8E-jmh-%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/","title":"Java 字符串拼接性能实测：基于 JMH 的微基准测试"}]